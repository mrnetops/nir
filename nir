#!/usr/bin/env perl

use Socket qw(:all);
use Getopt::Long;
use Data::Dumper;
use strict;
use warnings;

##
## Mr Netops nifty inline resolver
## Todd.Jimenez@gmail.com
##

%::commandLineOptions = (

	##
	## per http://stackoverflow.com/questions/106179/regular-expression-to-match-hostname-or-ip-address
	##
	## with some regexp bug fixes
	## 	* reversed the ip address octet subregexp to ensure we do a greedy match on the last octet
	##		otherwise we only match up to the first digit of the last octet.
	##	* added + to the [A-Za-z] hostname subregexp to ensure we do greedy matching on the top level domain
	##		otherwise we only match up to the first letter of the top level domain.
	##	* escape "." to prevent it doing an any character match instead of a literal "." match

	'ipAddressRegexp' =>
		'((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])',

	##
	## per http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
	##

	'ipV6AddressRegexp' =>
		'(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))',

	'hostnameRegexp' =>
		"(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\\.)+([A-Za-z]+|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])",
		#"(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\\.)*([A-Za-z]+|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])",
	'format' =>
		'[%s]',
	'timeout' =>
		2,
);

##
## Perl 5.14.0 or newer is required for IPv6 support
## Unless Socket is manually updated
##

eval {
	require 5.14.0;
};

if ($@) { 
	$::commandLineOptions{ipV6Support} = 0;
} else {
	$::commandLineOptions{ipV6Support} = 1;
}

@::getOptionsOptions = (
	\%::commandLineOptions,
	'ipAddressRegexp=s',
	'hostnameRegexp=s',
	'format=s',
	'verbose!',
	'debug!',
	'timeout=i',
	'help|?',
);

if (exists $ENV{'NIR'}) {
    @ARGV = (
        split(' ', $ENV{NIR}), @ARGV
    );
}

GetOptions(
        @::getOptionsOptions
) or exit 1;

if (exists $::commandLineOptions{help}) {
    print "
Mr. Netops nifty inline resolver
options:
	-ipAddressRegexp <regexp>
		Specify an alternate ip address regular expression
	-hostnameRegexp <regexp>
		Specify an alternate hostname regular expression
	-format
		Specify alternate formatting for resolved values
	-verbose
		Print additional status information to stderr
	-debug
		Print debugging information to stderr
	-timeout
		Dns lookup timeout
	-help
		This
";
	exit 0;
}
	
if (exists $::commandLineOptions{debug}) {
	$Data::Dumper::Varname = 'Configuration';
	&debug(
		Dumper(\%::commandLineOptions)
	);
}

if ($::commandLineOptions{ipV6Support}) {
	$::masterRegexp = join(
		"|",
		$::commandLineOptions{'ipAddressRegexp'},
		$::commandLineOptions{'ipV6AddressRegexp'},
		$::commandLineOptions{'hostnameRegexp'}
	);
} else {
	$::masterRegexp = join(
		"|",
		$::commandLineOptions{'ipAddressRegexp'},
		$::commandLineOptions{'hostnameRegexp'}
	);
}

while (<>) {
	$_ =~ s/($::masterRegexp)/&resolveMe($1)/ge;
	print $_;
}

sub resolveMe {
	my ($string) = @_;

	if (exists $::cache{$string}) { return $::cache{$string}; }

	$::cache{$string} = $string;

	if ($string =~ m/$::commandLineOptions{'ipAddressRegexp'}/) {

		&debug("gethostbyaddr [$string]");

		my $name;

		eval {
			alarm(0);
			local $SIG{ALRM} = sub { die; };
			alarm($::commandLineOptions{'timeout'});

			my $inet_aton = inet_aton($string);

			if (defined $inet_aton) {
				$name = gethostbyaddr($inet_aton, AF_INET);
			}

			alarm(0);
		};

		if ($@) { 

			&verbose("gethostbyaddr timeout [$string]");

			return $::cache{$string}; 
		}

		if (defined $name) {
			$::cache{$string} = $string . sprintf(
				$::commandLineOptions{'format'}, 
				$name
			);
		} 

	}

	if ($string =~ m/$::commandLineOptions{'hostnameRegexp'}/) {

		&debug("inet_ntoa [$string]");

		my @addresses = gethostbyname($string);
		if (@addresses) {
			@addresses = map {
				inet_ntoa($_)
			} @addresses[4 .. $#addresses];

			if ($addresses[0] ne $string) {
				$::cache{$string} = $string
					. "[" . join(",", @addresses) . "]";
			}

		}	
	}

	if ($string =~ m/$::commandLineOptions{'ipV6AddressRegexp'}/) {

		&getStarInfo("foo", $string);

	}

	return $::cache{$string};
}

##
## getaddrinfo / getnameinfo lookups
##

sub getStarInfo {
	my ($type, $string) = @_;

	my %hints = (
		flags => AI_CANONNAME,
	);

	my ($error, @addresses) = getaddrinfo(
		$string, 
		undef,
		\%hints
	);

	my %lookup;
	my %information;
	my $flags = 0;

	foreach my $address (@addresses) {

		if (exists $lookup{ $address->{addr} }) { next; }
		++$lookup{ $address->{addr} };

		if (
			$address->{canonname}
		) {
			++$information{canonname}{ $address->{canonname} };
		}

		eval {
			alarm(0);
			local $SIG{ALRM} = sub { die; };
			alarm($::commandLineOptions{'timeout'});

			my ($err, $hostname) = getnameinfo($address->{addr}, $flags);

			if ($hostname eq $string) { next; }

			if ($type eq 'hostname') {
				if ($address->{family} == AF_INET) { ++$information{ipv4}{$hostname}; }
				if ($address->{family} == AF_INET6) { ++$information{ipv6}{$hostname}; }
			} else {
				++$information{hostname}{$hostname};
			}

			alarm(0);
		};

		if ($@) { 
			&verbose("getnameinfo timeout [$string]: [$@]");
		}

		my @components;

		foreach my $key (keys %information) {
			foreach my $value (keys %{ $information{$key} }) {
				if ($value eq $string) { next; }
				push(@components, "${key}:${value}");
			}
		}

		if (@components) {
			$::cache{$string} = $string . sprintf(
				$::commandLineOptions{'format'}, 
				join(",", @components)
			);
		} 

	}
}

sub verbose {
	my ($message) = @_;

	if (
		exists $::commandLineOptions{'verbose'}
	) {
		print STDERR "VERBOSE: $message\n";
	}
}

sub debug {
	my ($message) = @_;

	if (
		exists $::commandLineOptions{'debug'}
	) {
		print STDERR "DEBUG: $message\n";
	}
}
