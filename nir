#!/usr/bin/env perl

##
## Mr Netops nifty inline resolver
## Copyright 2013 Todd Jimenez - Todd.Jimenez@gmail.com
## https://github.com/mrnetops/nir
##

##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License version 2 
## as published by the Free Software Foundation
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/gpl-2.0.html>.
##

use Socket qw(:all);
use Getopt::Long;
use Data::Dumper;
use strict;
use warnings;

%::commandLineOptions = (

##
## Per http://stackoverflow.com/questions/106179/regular-expression-to-match-hostname-or-ip-address
##
## with some regexp bug fixes
## 	* reversed the ip address octet subregexp to ensure we do a greedy
##	  match on the last octet otherwise we only match up to the first digit
##	  of the last octet.
##	* added + to the [A-Za-z] hostname subregexp to ensure we do greedy
##	  matching on the top level domain otherwise we only match up to the
##	  first letter of the top level domain.
##	* escape "." to prevent it doing an any character match instead of a
##	  literal "." match
##

	'ipAddressRegexp' =>
		'((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])',

##
## It's suprising difficult to find a good ipv6 regexp
## Massaged from Regexp::IPv6
##

	'ipV6AddressRegexp' =>
		'(?^::(:[0-9a-fA-F]{1,4}){0,5}((:[0-9a-fA-F]{1,4}){1,2}|:((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}|:)|(:([0-9a-fA-F]{1,4})?|((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4})?|))|(:((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(:((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(:[0-9a-fA-F]{1,4}){0,2})|:))|((:[0-9a-fA-F]{1,4}){0,2}(:((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(:[0-9a-fA-F]{1,4}){1,2})|:))|((:[0-9a-fA-F]{1,4}){0,3}(:((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(:[0-9a-fA-F]{1,4}){1,2})|:))|((:[0-9a-fA-F]{1,4}){0,4}(:((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(:[0-9a-fA-F]{1,4}){1,2})|:)))',

			'hostnameRegexp' =>
		"(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\\.)+([A-Za-z]+|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])",
		#"(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\\.)*([A-Za-z]+|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])",
	'format' =>
		'[%s]',
	'timeout' =>
		5,
	'find' => ['hostname', 'ipv4', 'ipv6', 'canonname'],
	
);

##
## Perl 5.14.0 or newer is required for IPv6 support
## Unless Socket is manually updated
##

eval {
	require 5.14.0;
};

if ($@) { 
	$::commandLineOptions{ipV6Support} = 0;
} else {
	$::commandLineOptions{ipV6Support} = 1;
}

@::getOptionsOptions = (
	\%::commandLineOptions,
	'ipAddressRegexp=s',
	'hostnameRegexp=s',
	'format=s',
	'verbose!',
	'debug!',
	'timeout=i',
	'find=s@',
	'help|?',
);

if (exists $ENV{'NIR'}) {
    @ARGV = (
        split(' ', $ENV{NIR}), @ARGV
    );
}

GetOptions(
        @::getOptionsOptions
) or exit 1;

if (exists $::commandLineOptions{help}) {
    print "
Mr. Netops nifty inline resolver
options:
	-ipAddressRegexp <regexp>
		Specify an alternate ip address regular expression
	-hostnameRegexp <regexp>
		Specify an alternate hostname regular expression
	-format
		Specify alternate formatting for resolved values
	-verbose
		Print additional status information to stderr
	-debug
		Print debugging information to stderr
	-timeout
		Dns lookup timeout
	-help
		This
";
	exit 0;
}
	
if (exists $::commandLineOptions{debug}) {
	$Data::Dumper::Varname = 'Configuration';
	$Data::Dumper::Sortkeys = 1;
	&debug(
		Dumper(\%::commandLineOptions)
	);
}

if ($::commandLineOptions{ipV6Support}) {
	$::masterRegexp = join(
		"|",
		$::commandLineOptions{'ipAddressRegexp'},
		$::commandLineOptions{'ipV6AddressRegexp'},
		$::commandLineOptions{'hostnameRegexp'}
	);
} else {
	$::masterRegexp = join(
		"|",
		$::commandLineOptions{'ipAddressRegexp'},
		$::commandLineOptions{'hostnameRegexp'}
	);
}

while (<>) {
	$_ =~ s/($::masterRegexp)/&resolveMe($1)/ge;
	print $_;
}

#if (exists $::commandLineOptions{debug}) {
#	$Data::Dumper::Varname = 'Cache';
#	$Data::Dumper::Sortkeys = 1;
#	&debug(
#		Dumper(\%::cache)
#	);
#}

sub resolveMe {
	my ($string) = @_;

	if (exists $::cache{$string}) { return $::cache{$string}; }
	$::cache{$string} = $string;

	if ($string =~ m/$::commandLineOptions{'ipAddressRegexp'}/) {
		&resolveMe_gethostbyaddr($string);
	}

	if ($string =~ m/$::commandLineOptions{'hostnameRegexp'}/) {
		#&resolveMe_gethostbyname($string);
		&resolveMe_getStarInfo("hostname", $string);
	}

	if ($string =~ m/$::commandLineOptions{'ipV6AddressRegexp'}/) {

		&resolveMe_getStarInfo("foo", $string);

	}

	return $::cache{$string};
}

sub resolveMe_hostname {
	if ($::commandLineOptions{ipV6Support}) {
		&resolveMe_getStarInfo('hostname', @_);
	} else {
		&resolveMe_gethostbyname(@_);
	}
}

sub resolveMe_gethostbyname {
	my ($string) = @_;

	&debug("gethostbyname [$string]");

	my @addresses = gethostbyname($string);
	if (@addresses) {
		@addresses = map {
			inet_ntoa($_)
		} @addresses[4 .. $#addresses];

		if ($addresses[0] ne $string) {
			$::cache{$string} = $string
				. "[" . join(",", @addresses) . "]";
		}
	}	
}

sub resolveMe_gethostbyaddr {
	my ($string) = @_;

	&debug("gethostbyaddr [$string]");

	my $name;

	eval {
		alarm(0);
		local $SIG{ALRM} = sub { die; };
		alarm($::commandLineOptions{'timeout'});

		my $inet_aton = inet_aton($string);

		if (defined $inet_aton) {
			$name = gethostbyaddr($inet_aton, AF_INET);
		}

		alarm(0);
	};

	if ($@) { 

		&verbose("gethostbyaddr timeout [$string]");

		return $::cache{$string}; 
	}

	if (defined $name) {
		$::cache{$string} = $string . sprintf(
			$::commandLineOptions{'format'}, 
			$name
		);
	} 
}

##
## getaddrinfo / getnameinfo lookups
##

sub resolveMe_getStarInfo {
	my ($type, $string) = @_;

	my %hints = (
		flags => AI_CANONNAME,
	);

	&debug("getaddrinfo [$string]");

	my ($error, @addresses) = getaddrinfo(
		$string, 
		undef,
		\%hints
	);

	my %lookup;
	my %information;
	my $flags = $type eq 'hostname' ? NI_NUMERICHOST : 0;

	foreach my $address (@addresses) {

		if (exists $lookup{ $address->{addr} }) { next; }
		++$lookup{ $address->{addr} };

		if (
			$address->{canonname}
		) {
			++$information{canonname}{ $address->{canonname} };
		}

		eval {
			alarm(0);
			local $SIG{ALRM} = sub { die; };
			alarm($::commandLineOptions{'timeout'});

			my ($err, $hostname) = getnameinfo($address->{addr}, $flags);

			if ($hostname eq $string) { return; }

			if ($type eq 'hostname') {
				if (
					$address->{family} == AF_INET
				) { ++$information{ipv4}{$hostname}; }
				if (
					$address->{family} == AF_INET6
				) { ++$information{ipv6}{$hostname}; }
			} else {
				++$information{hostname}{$hostname};
			}

			alarm(0);
		};

		if ($@) { 
			&verbose("getnameinfo timeout [$string]: [$@]");
		}

	}

	my @components;

	foreach my $key (keys %information) {
		foreach my $value (keys %{ $information{$key} }) {
			if ($value eq $string) { next; }
			push(@components, ${value});
		}
	}

	if (@components) {
		$::cache{$string} = $string . sprintf(
			$::commandLineOptions{'format'}, 
			join(",", @components)
		);
	}
}

sub verbose {
	my ($message) = @_;

	if (
		exists $::commandLineOptions{'verbose'}
	) {
		print STDERR "VERBOSE: $message\n";
	}
}

sub debug {
	my ($message) = @_;

	if (
		exists $::commandLineOptions{'debug'}
	) {
		print STDERR "DEBUG: $message\n";
	}
}
